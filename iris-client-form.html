<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iris-polymer-importer/iris-importer.html">
<link rel="import" href="../../bower_components/paper-input/paper-textarea.html">

<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/iris-polymer-screen-lock/iris-screen-lock.html">

<dom-module id="iris-client-form">
  <template>
    <style include="shared-styles"></style>
    <style>
      :host {
        display: block;
      }
    </style>

    <paper-input label$="[[currentField.description]]" value="[[applyMask(text)]]"></paper-input>
    <iris-screen-lock id="locker"></iris-screen-lock>
  </template>

  <script>
    'use strict';
    (function() {
      Polymer({
        is: 'iris-client-form',
        properties: {
          text: {
            type: String,
            notify: true
          },
          filledFields: {
            type: Object,
            notify: true,
            value: {}
          },
          fieldsModel: {
            type: Object,
            observer: '_fieldsModelChanged'
          },
          currentFieldName: {
            type: String,
            notify: true
          },
          currentFieldNumber: {
            type: Number,
            notify: true,
            value: 0
          },
          currentField: {
            type: Object,
            notify: true
          },
          isFinished: {
            type: Boolean,
            notify: true,
            value: false
          },
          isFirst: {
            type: Boolean,
            notify: true,
            value: true
          },
          maxLength: {
            type: Number,
            notify: true,
            computed: 'computeMaxLength(currentField)'
          }
        },
        computeMaxLength(currentField) {
          return currentField.mask ? (currentField.mask.match(/\*/g) || []).length : false;
        },
        _fieldsModelChanged() {
          this.reset();
        },
        validate() {

          let validate;
          if (_.isArray(this.currentField.validate)) {
            this.$.locker.lock();
            let validators = this.currentField.validate;
            validate = Promise.all(_.map(validators, validator => Promise.resolve(validator(this.filledFields))))
          } else {
            validate = Promise.resolve(true);
          }

          validate.then(() => this.$.locker.unlock())

          return validate.catch((e) => {
            console.log('silent error', e);
            this.$.locker.unlock();
            return false;
          });
        },
        next() {
          this.storeValue();

          return this.validate().then((result) => {
            if (~_.indexOf(result, false)) {
              this.fire('validation-error', {
                field: this.currentField,
                name: this.currentFieldName
              });
              return false;
            }
            if (this.isFinished) return true;
            this.setParams(this.currentFieldNumber + 1)
          });
        },
        applyMask(text) {
          if (!this.fieldsModel) return '';
          let mask = this.fieldsModel[this.currentFieldName].mask;


          if (!mask) return text;
          let placeholder_counter = 0;
          return _.map(mask.split(''), (symbol) => {
            if (symbol != '*') return symbol;
            let ch = text.charAt(placeholder_counter) || ' ';
            placeholder_counter += 1;
            return ch;
          }).join('');

        },
        checkBorders() {
          let keys = _.keys(this.fieldsModel);
          this.set('isFinished', this.currentFieldNumber === keys.length - 1);
          this.set('isFirst', this.currentFieldNumber === 0);
        },
        setParams(current) {
          let keys = _.keys(this.fieldsModel);
          this.set('currentFieldNumber', current);
          this.set('currentFieldName', keys[this.currentFieldNumber]);
          this.set('currentField', this.fieldsModel[this.currentFieldName]);
          let text = this.filledFields[this.currentFieldName] || this.fieldsModel[this.currentFieldName].default || '';
          this.set('text', text);

          this.checkBorders();
        },
        previous() {
          this.storeValue();

          return this.validate().then((result) => {
            if (~_.indexOf(result, false)) {
              this.fire('validation-error', {
                field: this.currentField,
                name: this.currentFieldName
              });
              return false;
            }
            if (this.isFirst) return true;
            this.setParams(this.currentFieldNumber - 1);
            return true;
          });
        },
        storeValue() {
          if (this.currentFieldName && this.text) {
            let real = this.visibleChars(this.text);

            this.set('filledFields.' + this.currentFieldName, real)
          }
        },
        visibleChars(text) {
          let mask = this.fieldsModel[this.currentFieldName].mask;

          if (!mask) return text;
          let mask_length = (mask.match(/\*/g) || []).length;
          return text.slice(0, mask_length);
        },
        reset(fields) {
          this.filledFields = fields || Object.create(null);
          this.$.locker.unlock();
          this.setParams(0);
        }
      });
    })();
  </script>

</dom-module>